{"ast":null,"code":"import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';\nimport { loadModule, logger, fill, arrayify, isThenable } from '@sentry/utils';\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils.js';\n\n/** Tracing integration for Apollo */\nclass Apollo {\n  constructor() {\n    Apollo.prototype.__init.call(this);\n  }\n  /**\n   * @inheritDoc\n   */\n  static __initStatic() {\n    this.id = 'Apollo';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  __init() {\n    this.name = Apollo.id;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setupOnce(_, getCurrentHub) {\n    const pkg = loadModule('apollo-server-core');\n    if (!pkg) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Apollo Integration was unable to require apollo-server-core package.');\n      return;\n    }\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Apollo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    /**\n     * Iterate over resolvers of the ApolloServer instance before schemas are constructed.\n     */\n    fill(pkg.ApolloServerBase.prototype, 'constructSchema', function (orig) {\n      return function () {\n        if (!this.config.resolvers) {\n          if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n            if (this.config.schema) {\n              logger.warn('Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.');\n            } else if (this.config.modules) {\n              logger.warn('Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property.');\n            }\n            logger.error('Skipping tracing as no resolvers found on the `ApolloServer` instance.');\n          }\n          return orig.call(this);\n        }\n        const resolvers = arrayify(this.config.resolvers);\n        this.config.resolvers = resolvers.map(model => {\n          Object.keys(model).forEach(resolverGroupName => {\n            Object.keys(model[resolverGroupName]).forEach(resolverName => {\n              if (typeof model[resolverGroupName][resolverName] !== 'function') {\n                return;\n              }\n              wrapResolver(model, resolverGroupName, resolverName, getCurrentHub);\n            });\n          });\n          return model;\n        });\n        return orig.call(this);\n      };\n    });\n  }\n}\nApollo.__initStatic();\n\n/**\n * Wrap a single resolver which can be a parent of other resolvers and/or db operations.\n */\nfunction wrapResolver(model, resolverGroupName, resolverName, getCurrentHub) {\n  fill(model[resolverGroupName], resolverName, function (orig) {\n    return function () {\n      const scope = getCurrentHub().getScope();\n      const parentSpan = _optionalChain([scope, 'optionalAccess', _2 => _2.getSpan, 'call', _3 => _3()]);\n      const span = _optionalChain([parentSpan, 'optionalAccess', _4 => _4.startChild, 'call', _5 => _5({\n        description: `${resolverGroupName}.${resolverName}`,\n        op: 'graphql.resolve'\n      })]);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const rv = orig.call(this, ...args);\n      if (isThenable(rv)) {\n        return rv.then(res => {\n          _optionalChain([span, 'optionalAccess', _6 => _6.finish, 'call', _7 => _7()]);\n          return res;\n        });\n      }\n      _optionalChain([span, 'optionalAccess', _8 => _8.finish, 'call', _9 => _9()]);\n      return rv;\n    };\n  });\n}\nexport { Apollo };","map":{"version":3,"mappings":";;;;AAcA;AACA;EAAAA;IAAAC;EAAA;EACA;;;EAGA;IAAA;EAAA;;EAEA;;;EAGAC;IAAA;EAAA;;EAEA;;;EAGAC;IACA,uBAMA;IAEA;MACA;MACA;IACA;IAEA;MACA;MACA;IACA;;IAEA;;;IAGAC;MACA;QACA;UACA;YACA;cACAC,YACA,sGACA;YACA;cACAA,YACA,uGACA;YACA;YAEAA;UACA;UAEA;QACA;QAEA;QAEA;UACAC;YACAA;cACA;gBACA;cACA;cAEAC;YACA;UACA;UAEA;QACA;QAEA;MACA;IACA;EACA;AACA;AAAAN;;AAEA;;;AAGA,sBACAO,OACAC,mBACAC,cACAC,eACA;EACAP;IACA;MACA;MACA;MACA;QACAQ;QACAC;MACA;MAAA,kCANAC;QAAAA;MAAA;MAQA;MAEA;QACA;UACAC;UACA;QACA;MACA;MAEAA;MAEA;IACA;EACA;AACA","names":["constructor","Apollo","__init","setupOnce","fill","logger","Object","wrapResolver","model","resolverGroupName","resolverName","getCurrentHub","description","op","args","_optionalChain"],"sources":["X:\\programowanie\\js\\ReactCourse\\http-app\\node_modules\\src\\integrations\\node\\apollo.ts"],"sourcesContent":["import { Hub } from '@sentry/core';\nimport { EventProcessor, Integration } from '@sentry/types';\nimport { arrayify, fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils';\n\ntype ApolloResolverGroup = {\n  [key: string]: () => unknown;\n};\n\ntype ApolloModelResolvers = {\n  [key: string]: ApolloResolverGroup;\n};\n\n/** Tracing integration for Apollo */\nexport class Apollo implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Apollo';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Apollo.id;\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    const pkg = loadModule<{\n      ApolloServerBase: {\n        prototype: {\n          constructSchema: () => unknown;\n        };\n      };\n    }>('apollo-server-core');\n\n    if (!pkg) {\n      __DEBUG_BUILD__ && logger.error('Apollo Integration was unable to require apollo-server-core package.');\n      return;\n    }\n\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      __DEBUG_BUILD__ && logger.log('Apollo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    /**\n     * Iterate over resolvers of the ApolloServer instance before schemas are constructed.\n     */\n    fill(pkg.ApolloServerBase.prototype, 'constructSchema', function (orig: () => unknown) {\n      return function (this: { config: { resolvers?: ApolloModelResolvers[]; schema?: unknown; modules?: unknown } }) {\n        if (!this.config.resolvers) {\n          if (__DEBUG_BUILD__) {\n            if (this.config.schema) {\n              logger.warn(\n                'Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.',\n              );\n            } else if (this.config.modules) {\n              logger.warn(\n                'Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property.',\n              );\n            }\n\n            logger.error('Skipping tracing as no resolvers found on the `ApolloServer` instance.');\n          }\n\n          return orig.call(this);\n        }\n\n        const resolvers = arrayify(this.config.resolvers);\n\n        this.config.resolvers = resolvers.map(model => {\n          Object.keys(model).forEach(resolverGroupName => {\n            Object.keys(model[resolverGroupName]).forEach(resolverName => {\n              if (typeof model[resolverGroupName][resolverName] !== 'function') {\n                return;\n              }\n\n              wrapResolver(model, resolverGroupName, resolverName, getCurrentHub);\n            });\n          });\n\n          return model;\n        });\n\n        return orig.call(this);\n      };\n    });\n  }\n}\n\n/**\n * Wrap a single resolver which can be a parent of other resolvers and/or db operations.\n */\nfunction wrapResolver(\n  model: ApolloModelResolvers,\n  resolverGroupName: string,\n  resolverName: string,\n  getCurrentHub: () => Hub,\n): void {\n  fill(model[resolverGroupName], resolverName, function (orig: () => unknown | Promise<unknown>) {\n    return function (this: unknown, ...args: unknown[]) {\n      const scope = getCurrentHub().getScope();\n      const parentSpan = scope?.getSpan();\n      const span = parentSpan?.startChild({\n        description: `${resolverGroupName}.${resolverName}`,\n        op: 'graphql.resolve',\n      });\n\n      const rv = orig.call(this, ...args);\n\n      if (isThenable(rv)) {\n        return rv.then((res: unknown) => {\n          span?.finish();\n          return res;\n        });\n      }\n\n      span?.finish();\n\n      return rv;\n    };\n  });\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}